{"version":3,"sources":["../../src/resolvers/message.js"],"names":["toCursorHash","string","Buffer","from","toString","fromCursorHash","Query","messages","parent","cursor","limit","models","cursorOptions","where","createdAt","Sequelize","Op","lt","Message","findAll","order","hasNextPage","length","edges","slice","pageInfo","endCursor","message","id","findByPk","Mutation","createMessage","isAuthenticated","text","me","create","userId","pubsub","publish","EVENTS","MESSAGE","CREATED","messageCreated","deleteMessage","isMessageOwner","destroy","updateMessage","update","returning","then","dataValues","user","args","User","Subscription","subscribe","asyncIterator"],"mappings":"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","sourcesContent":["// Allow for authentication checks\r\nimport { combineResolvers } from \"graphql-resolvers\";\r\n// Custom authentication methods\r\nimport { isAuthenticated, isMessageOwner } from \"./authorization\";\r\n// Implement cursor pagination\r\nimport Sequelize from \"sequelize\";\r\n// Subscription services for messages\r\nimport pubsub, { EVENTS } from \"../subscription\";\r\n\r\n// Date variables of cursor to/from hash\r\nconst toCursorHash = (string) => Buffer.from(string).toString(\"base64\");\r\nconst fromCursorHash = (string) =>\r\n  Buffer.from(string, \"base64\").toString(\"ascii\");\r\n\r\nexport default {\r\n  // Base query's\r\n  Query: {\r\n    // Multiple Messages\r\n    messages: async (parent, { cursor, limit = 100 }, { models }) => {\r\n      // If cursor, set location point else no options\r\n      const cursorOptions = cursor\r\n        ? {\r\n            where: {\r\n              createdAt: {\r\n                [Sequelize.Op.lt]: fromCursorHash(cursor),\r\n              },\r\n            },\r\n          }\r\n        : {};\r\n      // Return messages from cursor upto limit plus 1\r\n      const messages = await models.Message.findAll({\r\n        order: [[\"createdAt\", \"DESC\"]],\r\n        limit: limit + 1,\r\n        ...cursorOptions,\r\n      });\r\n\r\n      // Set if more messages are available\r\n      const hasNextPage = messages.length > limit;\r\n      // Set messages to edges based on if more messaged exist\r\n      const edges = hasNextPage ? messages.slice(0, -1) : messages;\r\n\r\n      return {\r\n        edges,\r\n        pageInfo: {\r\n          hasNextPage,\r\n          endCursor: toCursorHash(edges[edges.length - 1].createdAt.toString()),\r\n        },\r\n      };\r\n    },\r\n    // Single Message\r\n    message: async (parent, { id }, { models }) => {\r\n      return await models.Message.findByPk(id);\r\n    },\r\n  },\r\n\r\n  // Create, Update and Delete Mutations\r\n  Mutation: {\r\n    createMessage: combineResolvers(\r\n      isAuthenticated,\r\n      async (parent, { text }, { models, me }) => {\r\n        const message = await models.Message.create({\r\n          text,\r\n          userId: me.id,\r\n        });\r\n\r\n        pubsub.publish(EVENTS.MESSAGE.CREATED, {\r\n          messageCreated: { message },\r\n        });\r\n\r\n        return message;\r\n      }\r\n    ),\r\n\r\n    // Return boolean if delete is successful\r\n    deleteMessage: combineResolvers(\r\n      isAuthenticated,\r\n      isMessageOwner,\r\n      async (parent, { id }, { models }) => {\r\n        return await models.Message.destroy({ where: { id } });\r\n      }\r\n    ),\r\n    updateMessage: combineResolvers(\r\n      isAuthenticated,\r\n      isMessageOwner,\r\n      async (parent, { id, text }, { models }) => {\r\n        // Update message with user input and return updated message\r\n        return await models.Message.update(\r\n          { text: text },\r\n          { where: { id: id }, returning: true }\r\n        ).then((message) => {\r\n          return message[1][0].dataValues;\r\n        });\r\n      }\r\n    ),\r\n  },\r\n\r\n  // Define Message type return value\r\n  Message: {\r\n    // Return user object matching message userId\r\n    user: async (message, args, { models }) => {\r\n      return await models.User.findByPk(message.userId);\r\n    },\r\n  },\r\n\r\n  // Subscription services\r\n  Subscription: {\r\n    messageCreated: {\r\n      subscribe: () => pubsub.asyncIterator(EVENTS.MESSAGE.CREATED),\r\n    },\r\n  },\r\n};\r\n"],"file":"message.js"}