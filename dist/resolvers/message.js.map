{"version":3,"sources":["../../src/resolvers/message.js"],"names":["toCursorHash","string","Buffer","from","toString","fromCursorHash","Query","messages","parent","cursor","limit","models","cursorOptions","where","createdAt","Sequelize","Op","lt","Message","findAll","order","hasNextPage","length","edges","slice","pageInfo","endCursor","message","id","findByPk","Mutation","createMessage","isAuthenticated","text","me","create","userId","pubsub","publish","EVENTS","MESSAGE","CREATED","messageCreated","deleteMessage","isMessageOwner","destroy","updateMessage","update","returning","then","dataValues","user","args","User","Subscription","subscribe","asyncIterator"],"mappings":";;;;;;;AACA;;AAEA;;AAEA;;AAEA;;;;;;;;AAPA;AAEA;AAEA;AAEA;AAGA;AACA,MAAMA,YAAY,GAAIC,MAAD,IAAYC,MAAM,CAACC,IAAP,CAAYF,MAAZ,EAAoBG,QAApB,CAA6B,QAA7B,CAAjC;;AACA,MAAMC,cAAc,GAAIJ,MAAD,IACrBC,MAAM,CAACC,IAAP,CAAYF,MAAZ,EAAoB,QAApB,EAA8BG,QAA9B,CAAuC,OAAvC,CADF;;eAGe;AACb;AACAE,EAAAA,KAAK,EAAE;AACL;AACAC,IAAAA,QAAQ,EAAE,OAAOC,MAAP,EAAe;AAAEC,MAAAA,MAAF;AAAUC,MAAAA,KAAK,GAAG;AAAlB,KAAf,EAAwC;AAAEC,MAAAA;AAAF,KAAxC,KAAuD;AAC/D;AACA,YAAMC,aAAa,GAAGH,MAAM,GACxB;AACEI,QAAAA,KAAK,EAAE;AACLC,UAAAA,SAAS,EAAE;AACT,aAACC,mBAAUC,EAAV,CAAaC,EAAd,GAAmBZ,cAAc,CAACI,MAAD;AADxB;AADN;AADT,OADwB,GAQxB,EARJ,CAF+D,CAW/D;;AACA,YAAMF,QAAQ,GAAG,MAAMI,MAAM,CAACO,OAAP,CAAeC,OAAf,CAAuB;AAC5CC,QAAAA,KAAK,EAAE,CAAC,CAAC,WAAD,EAAc,MAAd,CAAD,CADqC;AAE5CV,QAAAA,KAAK,EAAEA,KAAK,GAAG,CAF6B;AAG5C,WAAGE;AAHyC,OAAvB,CAAvB,CAZ+D,CAkB/D;;AACA,YAAMS,WAAW,GAAGd,QAAQ,CAACe,MAAT,GAAkBZ,KAAtC,CAnB+D,CAoB/D;;AACA,YAAMa,KAAK,GAAGF,WAAW,GAAGd,QAAQ,CAACiB,KAAT,CAAe,CAAf,EAAkB,CAAC,CAAnB,CAAH,GAA2BjB,QAApD;AAEA,aAAO;AACLgB,QAAAA,KADK;AAELE,QAAAA,QAAQ,EAAE;AACRJ,UAAAA,WADQ;AAERK,UAAAA,SAAS,EAAE1B,YAAY,CAACuB,KAAK,CAACA,KAAK,CAACD,MAAN,GAAe,CAAhB,CAAL,CAAwBR,SAAxB,CAAkCV,QAAlC,EAAD;AAFf;AAFL,OAAP;AAOD,KAhCI;AAiCL;AACAuB,IAAAA,OAAO,EAAE,OAAOnB,MAAP,EAAe;AAAEoB,MAAAA;AAAF,KAAf,EAAuB;AAAEjB,MAAAA;AAAF,KAAvB,KAAsC;AAC7C,aAAO,MAAMA,MAAM,CAACO,OAAP,CAAeW,QAAf,CAAwBD,EAAxB,CAAb;AACD;AApCI,GAFM;AAyCb;AACAE,EAAAA,QAAQ,EAAE;AACRC,IAAAA,aAAa,EAAE,wCACbC,8BADa,EAEb,OAAOxB,MAAP,EAAe;AAAEyB,MAAAA;AAAF,KAAf,EAAyB;AAAEtB,MAAAA,MAAF;AAAUuB,MAAAA;AAAV,KAAzB,KAA4C;AAC1C,YAAMP,OAAO,GAAG,MAAMhB,MAAM,CAACO,OAAP,CAAeiB,MAAf,CAAsB;AAC1CF,QAAAA,IAD0C;AAE1CG,QAAAA,MAAM,EAAEF,EAAE,CAACN;AAF+B,OAAtB,CAAtB;;AAKAS,4BAAOC,OAAP,CAAeC,qBAAOC,OAAP,CAAeC,OAA9B,EAAuC;AACrCC,QAAAA,cAAc,EAAE;AAAEf,UAAAA;AAAF;AADqB,OAAvC;;AAIA,aAAOA,OAAP;AACD,KAbY,CADP;AAiBR;AACAgB,IAAAA,aAAa,EAAE,wCACbX,8BADa,EAEbY,6BAFa,EAGb,OAAOpC,MAAP,EAAe;AAAEoB,MAAAA;AAAF,KAAf,EAAuB;AAAEjB,MAAAA;AAAF,KAAvB,KAAsC;AACpC,aAAO,MAAMA,MAAM,CAACO,OAAP,CAAe2B,OAAf,CAAuB;AAAEhC,QAAAA,KAAK,EAAE;AAAEe,UAAAA;AAAF;AAAT,OAAvB,CAAb;AACD,KALY,CAlBP;AAyBRkB,IAAAA,aAAa,EAAE,wCACbd,8BADa,EAEbY,6BAFa,EAGb,OAAOpC,MAAP,EAAe;AAAEoB,MAAAA,EAAF;AAAMK,MAAAA;AAAN,KAAf,EAA6B;AAAEtB,MAAAA;AAAF,KAA7B,KAA4C;AAC1C;AACA,aAAO,MAAMA,MAAM,CAACO,OAAP,CAAe6B,MAAf,CACX;AAAEd,QAAAA,IAAI,EAAEA;AAAR,OADW,EAEX;AAAEpB,QAAAA,KAAK,EAAE;AAAEe,UAAAA,EAAE,EAAEA;AAAN,SAAT;AAAqBoB,QAAAA,SAAS,EAAE;AAAhC,OAFW,EAGXC,IAHW,CAGLtB,OAAD,IAAa;AAClB,eAAOA,OAAO,CAAC,CAAD,CAAP,CAAW,CAAX,EAAcuB,UAArB;AACD,OALY,CAAb;AAMD,KAXY;AAzBP,GA1CG;AAkFb;AACAhC,EAAAA,OAAO,EAAE;AACP;AACAiC,IAAAA,IAAI,EAAE,OAAOxB,OAAP,EAAgByB,IAAhB,EAAsB;AAAEzC,MAAAA;AAAF,KAAtB,KAAqC;AACzC,aAAO,MAAMA,MAAM,CAAC0C,IAAP,CAAYxB,QAAZ,CAAqBF,OAAO,CAACS,MAA7B,CAAb;AACD;AAJM,GAnFI;AA0Fb;AACAkB,EAAAA,YAAY,EAAE;AACZZ,IAAAA,cAAc,EAAE;AACda,MAAAA,SAAS,EAAE,MAAMlB,sBAAOmB,aAAP,CAAqBjB,qBAAOC,OAAP,CAAeC,OAApC;AADH;AADJ;AA3FD,C","sourcesContent":["// Allow for authentication checks\nimport { combineResolvers } from \"graphql-resolvers\";\n// Custom authentication methods\nimport { isAuthenticated, isMessageOwner } from \"./authorization\";\n// Implement cursor pagination\nimport Sequelize from \"sequelize\";\n// Subscription services for messages\nimport pubsub, { EVENTS } from \"../subscription\";\n\n// Date variables of cursor to/from hash\nconst toCursorHash = (string) => Buffer.from(string).toString(\"base64\");\nconst fromCursorHash = (string) =>\n  Buffer.from(string, \"base64\").toString(\"ascii\");\n\nexport default {\n  // Base query's\n  Query: {\n    // Multiple Messages\n    messages: async (parent, { cursor, limit = 100 }, { models }) => {\n      // If cursor, set location point else no options\n      const cursorOptions = cursor\n        ? {\n            where: {\n              createdAt: {\n                [Sequelize.Op.lt]: fromCursorHash(cursor),\n              },\n            },\n          }\n        : {};\n      // Return messages from cursor upto limit plus 1\n      const messages = await models.Message.findAll({\n        order: [[\"createdAt\", \"DESC\"]],\n        limit: limit + 1,\n        ...cursorOptions,\n      });\n\n      // Set if more messages are available\n      const hasNextPage = messages.length > limit;\n      // Set messages to edges based on if more messaged exist\n      const edges = hasNextPage ? messages.slice(0, -1) : messages;\n\n      return {\n        edges,\n        pageInfo: {\n          hasNextPage,\n          endCursor: toCursorHash(edges[edges.length - 1].createdAt.toString()),\n        },\n      };\n    },\n    // Single Message\n    message: async (parent, { id }, { models }) => {\n      return await models.Message.findByPk(id);\n    },\n  },\n\n  // Create, Update and Delete Mutations\n  Mutation: {\n    createMessage: combineResolvers(\n      isAuthenticated,\n      async (parent, { text }, { models, me }) => {\n        const message = await models.Message.create({\n          text,\n          userId: me.id,\n        });\n\n        pubsub.publish(EVENTS.MESSAGE.CREATED, {\n          messageCreated: { message },\n        });\n\n        return message;\n      }\n    ),\n\n    // Return boolean if delete is successful\n    deleteMessage: combineResolvers(\n      isAuthenticated,\n      isMessageOwner,\n      async (parent, { id }, { models }) => {\n        return await models.Message.destroy({ where: { id } });\n      }\n    ),\n    updateMessage: combineResolvers(\n      isAuthenticated,\n      isMessageOwner,\n      async (parent, { id, text }, { models }) => {\n        // Update message with user input and return updated message\n        return await models.Message.update(\n          { text: text },\n          { where: { id: id }, returning: true }\n        ).then((message) => {\n          return message[1][0].dataValues;\n        });\n      }\n    ),\n  },\n\n  // Define Message type return value\n  Message: {\n    // Return user object matching message userId\n    user: async (message, args, { models }) => {\n      return await models.User.findByPk(message.userId);\n    },\n  },\n\n  // Subscription services\n  Subscription: {\n    messageCreated: {\n      subscribe: () => pubsub.asyncIterator(EVENTS.MESSAGE.CREATED),\n    },\n  },\n};\n"],"file":"message.js"}